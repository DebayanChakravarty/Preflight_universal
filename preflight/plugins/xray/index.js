import { toGrayscale, stddev, laplacianVariance, loadImage } from '../../core/utils.js';
const POLICY={jpgpng:{size_hi:25,size_mid:15,size_low:6,contrast_hi:25,contrast_mid:15,contrast_low:6,sharp_hi:25,sharp_mid:15,sharp_low:6,center_hi:10,center_mid:6,center_low:2,vignette_penalty:-10,notes_bonus:5},thresholds:{accept:85,borderline:70}};
export default{name:'xray-plus',thresholds:POLICY.thresholds,async analyze(file,ui){const ext=(file.name||'').toLowerCase().split('.').pop();if(ext==='dcm'||(file.type&&/dicom/i.test(file.type))){return analyzeDICOMStub(file);}if(/(jpe?g|png|bmp|webp)$/i.test(file.name)){return analyzeRadiographImage(file,ui);}return{score:55,messages:['Not a recognized radiograph format — falling back.'],details:[]};}};
async function analyzeRadiographImage(file,{status,notes}){const W=POLICY.jpgpng;status.textContent='Decoding radiograph…';const imgEl=await loadImage(file);const w=imgEl.naturalWidth,h=imgEl.naturalHeight;const canvas=document.createElement('canvas');canvas.width=w;canvas.height=h;const ctx=canvas.getContext('2d',{willReadFrequently:true});ctx.drawImage(imgEl,0,0);const img=ctx.getImageData(0,0,w,h);const g=toGrayscale(img);const megapx=(w*h)/1e6;const contrast=stddev(g);const lapVar=laplacianVariance(g,w,h);
const cx=Math.floor(w/2),cy=Math.floor(h/2);const r=Math.floor(Math.min(w,h)*0.1);let centerSum=0,centerN=0;for(let y=cy-r;y<=cy+r;y++){for(let x=cx-r;x<=cx+r;x++){const dx=x-cx,dy=y-cy;if(dx*dx+dy*dy<=r*r){centerSum+=g[y*w+x];centerN++;}}}const centerMean=centerN?centerSum/centerN:0;
const cornerPts=[[Math.floor(w*0.07),Math.floor(h*0.07)],[Math.floor(w*0.93),Math.floor(h*0.07)],[Math.floor(w*0.07),Math.floor(h*0.93)],[Math.floor(w*0.93),Math.floor(h*0.93)]];let cornerSum=0,cornerN=0;const rr=Math.floor(Math.min(w,h)*0.05);for(const [px,py] of cornerPts){for(let y=py-rr;y<=py+rr;y++){for(let x=px-rr;x<=px+rr;x++){const dx=x-px,dy=y-py;if(dx*dx+dy*dy<=rr*rr){cornerSum+=g[y*w+x];cornerN++;}}}}const cornerMean=cornerN?cornerSum/cornerN:0;const vignette=centerMean-cornerMean;
let score=0,det=[],msg=[];det.push(`MP: ${megapx.toFixed(2)}`);if(megapx>=3.0)score+=W.size_hi;else if(megapx>=1.5){score+=W.size_mid;msg.push('Low resolution — target ≥ 3MP for fine detail.');}else{score+=W.size_low;msg.push('Very low resolution — details may be lost.');}
det.push(`Sharpness(LapVar/100): ${lapVar.toFixed(1)}`);if(lapVar>140)score+=W.sharp_hi;else if(lapVar>=80){score+=W.sharp_mid;msg.push('Slight blur — stabilize or increase exposure.');}else{score+=W.sharp_low;msg.push('Blurry — repeat capture.');}
det.push(`Contrast(stddev): ${contrast.toFixed(1)}`);if(contrast>=40)score+=W.contrast_hi;else if(contrast>=28){score+=W.contrast_mid;msg.push('Low contrast — adjust exposure/processing.');}else{score+=W.contrast_low;msg.push('Very low contrast — bones may be indistinct.');}
det.push(`Center mean: ${centerMean.toFixed(1)} · Corner mean: ${cornerMean.toFixed(1)} · Δ: ${vignette.toFixed(1)}`);if(Math.abs(vignette)<=10)score+=W.center_hi;else if(Math.abs(vignette)<=25)score+=W.center_mid;else score+=W.center_low;if(vignette>25){score+=W.vignette_penalty;msg.push('Strong vignette/dark corners — consider flat-field correction.');}
score+=W.notes_bonus;msg.push(...['Ensure anatomy fully within field; avoid clipping at edges.','Keep detector parallel to anatomy to minimize distortion.','Avoid motion — use stabilizers or shorter exposure if possible.']);notes.textContent=det.join('\n');return{score:Math.max(0,Math.min(100,score)),messages:dedupe(msg),details:det};}
function dedupe(arr){const s=new Set(),out=[];for(const x of arr){const k=String(x).trim();if(k&&!s.has(k)){s.add(k);out.push(k);}}return out;}
async function analyzeDICOMStub(file){return{score:72,messages:['DICOM path stubbed: series/metadata checks would run server-side or via a DICOM library.','Consider validating pixel spacing, orientation, study/series completeness.'],details:['Format: DICOM (.dcm)','Client demo focuses on JPG/PNG radiographs.']};}
